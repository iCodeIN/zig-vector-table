pub fn build(b: *std.build.Builder) !void {
    const display_option = b.option(bool, "display", "graphics display for qemu") orelse false;
    const exe = b.addExecutable("main", "main.zig");
    exe.install();
    exe.setBuildMode(b.standardReleaseOptions());
    exe.setLinkerScriptPath(GenerateLinkerScriptStep.file_name);
    exe.setTarget(model.target);
    exe.link_function_sections = true;
    const fmt = b.addFmt(&[_][]const u8{ "build.zig", "main.zig" });
    const generate = addCustomStep(b, GenerateLinkerScriptStep{});
    const install_raw = b.addInstallRaw(exe, "main.img");
    const run_make_hex = addCustomStep(b, MakeHexStep{ .input_name = "zig-cache/bin/main.img", .output_name = "main.hex" });
    const make_hex = b.step("make-hex", "make hex file to copy to device");
    const run_qemu = b.addSystemCommand(&[_][]const u8{
        "qemu-system-arm",
        "-kernel",
        "zig-cache/bin/main.img",
        "-M",
        model.qemu.machine,
        "-serial",
        "stdio",
        "-display",
        if (display_option) "gtk" else "none",
    });
    const qemu = b.step("qemu", "run in qemu");

    exe.step.dependOn(&generate.step);
    generate.step.dependOn(&fmt.step);
    install_raw.step.dependOn(&exe.step);
    run_make_hex.step.dependOn(&install_raw.step);
    make_hex.dependOn(&run_make_hex.step);
    run_qemu.step.dependOn(&install_raw.step);
    qemu.dependOn(&run_qemu.step);
    b.default_step.dependOn(&exe.step);
}

pub const model = struct {
    pub const flash = MemoryRegion{
        .name = "flash",
        .access = "rx",
        .start = 0,
        .size = 256 * 1024,
        .sections = &[_]MemoryRegion.Section{
            .{ .pattern = ".vector_table*", .keep = true },
            .{ .pattern = ".text*" },
            .{ .pattern = ".rodata*" },
        },
    };
    pub const flash_then_ram = MemoryRegion{
        .name = "flash_then_ram",
        .source = &flash,
        .destination = &ram,
        .sections = &[_]MemoryRegion.Section{
            .{ .pattern = ".data*", .externs_prefix = "__data_" },
        },
    };
    pub const linked = struct {
        extern var __bss_start: u8;
        extern var __bss_end: u8;
        extern var __data_start: u8;
        extern var __data_end: u8;
        extern var __flash_then_ram_start: u8;
        pub fn prepareMemory() void {
            var bss = slice(&__bss_start, &__bss_end);
            var data = slice(&__data_start, &__data_end);
            var flash_then_ram_stored = @ptrCast([*]u8, &__flash_then_ram_start)[0..data.len];
            std.mem.copy(u8, data, flash_then_ram_stored);
            std.mem.set(u8, bss, 0);
        }
        fn slice(start: *u8, end: *u8) []u8 {
            return @ptrCast([*]u8, start)[0 .. @ptrToInt(end) - @ptrToInt(start)];
        }
    };
    pub const memories = [_]MemoryRegion{ flash, flash_then_ram, ram };
    pub const number_of_peripherals = 32;
    pub const options = struct {
        pub const low_frequency_crystal = false;
        pub const systick_timer = false;
        pub const vector_table_relocation_register = false;
    };
    pub const qemu = struct {
        pub const machine = "microbit";
    };
    pub const ram = MemoryRegion{
        .name = "ram",
        .noload = true,
        .access = "rwx",
        .start = 0x20000000,
        .size = 16 * 1024,
        .sections = &[_]MemoryRegion.Section{
            .{ .pattern = ".bss*", .externs_prefix = "__bss_" },
        },
    };
    pub const stack_bottom = ram.start + ram.size;
    pub const target = std.zig.CrossTarget{
        .cpu_arch = .thumb,
        .os_tag = .freestanding,
        .abi = .none,
        .cpu_model = std.zig.CrossTarget.CpuModel{ .explicit = &std.Target.arm.cpu.cortex_m0 },
    };
    const MemoryRegion = struct {
        access: []const u8 = "",
        destination: ?*const MemoryRegion = null,
        name: []const u8,
        noload: bool = false,
        sections: []const Section,
        size: u32 = 0,
        source: ?*const MemoryRegion = null,
        start: u32 = 0,
        const Section = struct {
            externs_prefix: ?[]const u8 = null,
            keep: bool = false,
            pattern: []const u8,
        };
    };
};

const GenerateLinkerScriptStep = struct {
    step: std.build.Step = undefined,
    pub fn make(step: *std.build.Step) anyerror!void {
        var file = try fs.cwd().createFile(file_name, fs.File.CreateFlags{});
        defer file.close();
        try file.outStream().print(
            \\# {} - do not edit - generated by build.zig
            \\
            \\MEMORY {{
            \\
        , .{file_name});
        for (model.memories) |mem| {
            if (mem.destination == null and mem.source == null) {
                try file.outStream().print(
                    \\    {} ({}) : ORIGIN = 0x{x}, LENGTH = 0x{x}
                    \\
                , .{ mem.name, mem.access, mem.start, mem.size });
            }
        }
        try file.outStream().writeAll(
            \\}
            \\
            \\SECTIONS {
            \\    /DISCARD/ : {
            \\        *(.ARM.exidx)
            \\    }
            \\
            \\
        );
        for (model.memories) |mem| {
            if (mem.destination != null or mem.source != null) {
                try file.outStream().print(
                    \\    __{}_start = .;
                    \\    .{} : AT(__{}_start) {{
                    \\
                , .{ mem.name, mem.name, mem.name });
            } else if (mem.noload) {
                try file.outStream().print(
                    \\    .{} (NOLOAD) : {{
                    \\
                , .{mem.name});
            } else {
                try file.outStream().print(
                    \\    .{} : {{
                    \\
                , .{mem.name});
            }
            for (mem.sections) |sec| {
                if (sec.externs_prefix) |prefix| {
                    try file.outStream().print(
                        \\        {}start = .;
                        \\
                    , .{prefix});
                }
                if (sec.keep) {
                    try file.outStream().print(
                        \\        KEEP(*({}))
                        \\
                    , .{sec.pattern});
                } else {
                    try file.outStream().print(
                        \\        *({})
                        \\
                    , .{sec.pattern});
                }
                if (sec.externs_prefix) |prefix| {
                    try file.outStream().print(
                        \\        {}end = .;
                        \\
                    , .{prefix});
                }
            }
            const destination = mem.destination orelse &mem;
            try file.outStream().print(
                \\    }} > {}
                \\
                \\
            , .{(mem.destination orelse &mem).name});
        }
        try file.outStream().writeAll(
            \\}
        );
    }
    const file_name = "generated-linker.ld";
};

const MakeHexStep = struct {
    step: std.build.Step = undefined,
    input_name: []const u8,
    output_name: []const u8,
    pub fn make(step: *std.build.Step) anyerror!void {
        const self = @fieldParentPtr(MakeHexStep, "step", step);
        const cwd = fs.cwd();
        const image = try cwd.openFile(self.input_name, fs.File.OpenFlags{});
        defer image.close();
        const hex = try cwd.createFile(self.output_name, fs.File.CreateFlags{});
        defer hex.close();
        var offset: usize = 0;
        var read_buf: [model.flash.size]u8 = undefined;
        while (true) {
            var n = try image.read(&read_buf);
            if (n == 0) {
                break;
            }
            while (offset < n) {
                if (offset % 0x10000 == 0) {
                    try writeHexRecord(hex, 0, 0x04, &[_]u8{ @truncate(u8, offset >> 24), @truncate(u8, offset >> 16) });
                }
                const i = std.math.min(hex_record_len, n - offset);
                try writeHexRecord(hex, offset % 0x10000, 0x00, read_buf[offset .. offset + i]);
                offset += i;
            }
        }
        try writeHexRecord(hex, 0, 0x01, &[_]u8{});
    }
    fn writeHexRecord(file: fs.File, offset: usize, code: u8, bytes: []u8) !void {
        var record_buf: [1 + 2 + 1 + hex_record_len + 1]u8 = undefined;
        var record: []u8 = record_buf[0 .. 1 + 2 + 1 + bytes.len + 1];
        record[0] = @truncate(u8, bytes.len);
        record[1] = @truncate(u8, offset >> 8);
        record[2] = @truncate(u8, offset >> 0);
        record[3] = code;
        for (bytes) |b, i| {
            record[4 + i] = b;
        }
        var checksum: u8 = 0;
        for (record[0 .. record.len - 1]) |b| {
            checksum = checksum -% b;
        }
        record[record.len - 1] = checksum;
        var line_buf: [1 + record_buf.len * 2 + 1]u8 = undefined;
        _ = try file.write(try std.fmt.bufPrint(&line_buf, ":{X}\n", .{record}));
    }
    const hex_record_len = 32;
};

pub fn addCustomStep(self: *std.build.Builder, customStep: var) *@TypeOf(customStep) {
    var allocated = self.allocator.create(@TypeOf(customStep)) catch unreachable;
    allocated.* = customStep;
    allocated.*.step = Step.init(@typeName(@TypeOf(customStep)), self.allocator, @TypeOf(customStep).make);
    return allocated;
}

const fs = std.fs;
const std = @import("std");
const Step = std.build.Step;
