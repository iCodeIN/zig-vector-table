pub fn build(b: *std.build.Builder) !void {
    const display_option = b.option(bool, "display", "graphics display for qemu") orelse false;
    const build_exe = b.addExecutable("main", "main.zig");
    build_exe.install();
    build_exe.setBuildMode(b.standardReleaseOptions());
    build_exe.setLinkerScriptPath(Linker.script_file_name);
    build_exe.setTarget(model.target);
    build_exe.link_function_sections = true;
    const format_source = b.addFmt(&[_][]const u8{ "build.zig", "main.zig" });
    const generate_linker_files = addCustomStep(b, GenerateLinkerFiles{});
    const install_raw = b.addInstallRaw(build_exe, "main.img");
    const make_hex_file = addCustomStep(b, MakeHexStep{ .input_name = "zig-cache/bin/main.img", .output_name = "main.hex" });
    const run_qemu = b.addSystemCommand(&[_][]const u8{
        "qemu-system-arm",
        "-kernel",
        "zig-cache/bin/main.img",
        "-M",
        model.qemu.machine,
        "-serial",
        "stdio",
        "-display",
        if (display_option) "gtk" else "none",
    });

    declareDependencies: {
        build_exe.step.dependOn(&format_source.step);
        build_exe.step.dependOn(&generate_linker_files.step);
        install_raw.step.dependOn(&build_exe.step);
        make_hex_file.step.dependOn(&install_raw.step);
        run_qemu.step.dependOn(&install_raw.step);
    }

    declareCommandLineSteps: {
        b.step("make-hex", "make hex file to copy to device").dependOn(&make_hex_file.step);
        b.step("qemu", "run in qemu").dependOn(&run_qemu.step);
        b.default_step.dependOn(&build_exe.step);
    }
}

pub const model = struct {
    fn link() !void {
        try Linker.discardSections(&[_][]const u8{".ARM.exidx"});
        try flash.link();
        try ram.link();
    }
    pub const flash = struct {
        const name = "flash";
        const size = 256 * 1024;
        const start = 0;
        fn link() !void {
            try Linker.memory(name, size, start);
            try Linker.sections(.{ .keep = true }, &[_][]const u8{".vector_table*"});
            try Linker.sections(.{}, &[_][]const u8{".text*"});
            try Linker.sections(.{}, &[_][]const u8{".rodata*"});
        }
    };
    pub const number_of_peripherals = 32;
    pub const options = struct {
        pub const low_frequency_crystal = false;
        pub const systick_timer = false;
        pub const vector_table_relocation_register = false;
    };
    pub const qemu = struct {
        pub const machine = "microbit";
    };
    pub const ram = struct {
        const name = "ram";
        const size = 16 * 1024;
        const start = 0x20000000;
        fn link() !void {
            try Linker.memory(name, size, start);
            try Linker.sections(.{ .name = "data", .prepare_by_copying_from = flash }, &[_][]const u8{".data*"});
            try Linker.sections(.{ .name = "bss", .prepare_by_setting_to_zero = true }, &[_][]const u8{".bss*"});
        }
    };
    pub const stack_bottom = ram.start + ram.size;
    pub const target = std.zig.CrossTarget{
        .cpu_arch = .thumb,
        .os_tag = .freestanding,
        .abi = .none,
        .cpu_model = std.zig.CrossTarget.CpuModel{ .explicit = &std.Target.arm.cpu.cortex_m0 },
    };
};

const Linker = struct {
    fn link() !void {
        externs_file = try fs.cwd().createFile(externs_file_name, fs.File.CreateFlags{});
        defer externs_file.close();
        externs = externs_file.outStream();
        prepare_memory_file = try fs.cwd().createFile(prepare_memory_file_name, fs.File.CreateFlags{});
        defer prepare_memory_file.close();
        prepare_memory = prepare_memory_file.outStream();
        script_file = try fs.cwd().createFile(script_file_name, fs.File.CreateFlags{});
        defer script_file.close();
        script = script_file.outStream();
        try externs.print(
            \\// {} - do not edit - generated by build.zig
            \\
        , .{externs_file_name});
        try prepare_memory.print(
            \\// {} - do not edit - generated by build.zig
            \\
            \\pub fn prepareMemory() void {{
            \\
        , .{prepare_memory_file_name});
        try script.print(
            \\# {} - do not edit - generated by build.zig
            \\
        , .{script_file_name});
        try model.link();
        try prepare_memory.writeAll(
            \\}
            \\
            \\const externs = @import("generated_externs.zig");
            \\const std = @import("std");
            \\
        );
    }
    fn memory(name: []const u8, size: u32, start: u32) !void {
        current_memory_name = name;
        try script.print(
            \\
            \\MEMORY {{
            \\    {} : ORIGIN = 0x{x}, LENGTH = 0x{x}
            \\}}
            \\
        , .{ name, start, size });
    }
    fn discardSections(patterns: []const []const u8) !void {
        try script.writeAll(
            \\
            \\SECTIONS {
            \\    /DISCARD/ : {
            \\
        );
        for (patterns) |p| {
            try script.print(
                \\        *({})
                \\
            , .{p});
        }
        try script.writeAll(
            \\    }
            \\}
            \\
        );
    }
    fn sections(comptime options: SectionOptions, patterns: []const []const u8) !void {
        if (options.prepare_by_copying_from) |mem| {
            try script.print(
                \\
                \\SECTIONS {{
                \\    __{}_load_start = {}_clc;
                \\    .some_section_name : AT({}_clc) {{
                \\        __{}_start = .;
                \\
            , .{ options.name, mem.name, mem.name, options.name });
            try externs.print(
                \\
                \\pub extern var __{}_start: u8;
                \\pub extern var __{}_end: u8;
                \\pub extern var __{}_load_start: u8;
                \\
            , .{ options.name, options.name, options.name });
            try prepare_memory.print(
                \\    var {}_destination = @ptrCast([*]u8, &externs.__{}_start)[0 .. @ptrToInt(&externs.__{}_end) - @ptrToInt(&externs.__{}_start)];
                \\    var {}_loaded = @ptrCast([*]u8, &externs.__{}_load_start)[0..{}_destination.len];
                \\    std.mem.copy(u8, {}_destination, {}_loaded);
                \\
            , .{ options.name, options.name, options.name, options.name, options.name, options.name, options.name, options.name, options.name });
        } else if (options.prepare_by_setting_to_zero) {
            try script.print(
                \\
                \\SECTIONS {{
                \\    .some_section_name (NOLOAD) : {{
                \\        __{}_start = .;
                \\
            , .{options.name});
            try externs.print(
                \\
                \\pub extern var __{}_start: u8;
                \\pub extern var __{}_end: u8;
                \\
            , .{ options.name, options.name });
            try prepare_memory.print(
                \\    var {} = @ptrCast([*]u8, &externs.__{}_start)[0 .. @ptrToInt(&externs.__{}_end) - @ptrToInt(&externs.__{}_start)];
                \\    std.mem.set(u8, {}, 0);
                \\
            , .{ options.name, options.name, options.name, options.name, options.name });
        } else {
            try script.writeAll(
                \\
                \\SECTIONS {
                \\    .some_section_name : {
                \\
            );
        }
        for (patterns) |p| {
            if (options.keep) {
                try script.print(
                    \\        KEEP(*({}))
                    \\
                , .{p});
            } else {
                try script.print(
                    \\        *({})
                    \\
                , .{p});
            }
        }
        if (options.prepare_by_setting_to_zero) {
            try script.print(
                \\        __{}_end = .;
                \\
            , .{options.name});
        } else if (options.prepare_by_copying_from) |_| {
            try script.print(
                \\        __{}_end = .;
                \\
            , .{options.name});
        }
        try script.print(
            \\        {}_clc = .;
            \\    }} > {}
            \\}}
            \\
        , .{ current_memory_name, current_memory_name });
    }
    const externs_file_name = "generated_externs.zig";
    const prepare_memory_file_name = "generated_prepare_memory.zig";
    const script_file_name = "generated_linker_script.ld";
    const SectionOptions = struct {
        keep: bool = false,
        name: ?[]const u8 = null,
        prepare_by_copying_from: ?type = null,
        prepare_by_setting_to_zero: bool = false,
    };
    var current_memory_name: []const u8 = undefined;
    var externs: std.io.OutStream(fs.File, std.os.WriteError, fs.File.write) = undefined;
    var externs_file: fs.File = undefined;
    var prepare_memory: std.io.OutStream(fs.File, std.os.WriteError, fs.File.write) = undefined;
    var prepare_memory_file: fs.File = undefined;
    var script: std.io.OutStream(fs.File, std.os.WriteError, fs.File.write) = undefined;
    var script_file: fs.File = undefined;
};

const GenerateLinkerFiles = struct {
    step: std.build.Step = undefined,
    pub fn make(step: *std.build.Step) anyerror!void {
        try Linker.link();
    }
};

const MakeHexStep = struct {
    step: std.build.Step = undefined,
    input_name: []const u8,
    output_name: []const u8,
    pub fn make(step: *std.build.Step) anyerror!void {
        const self = @fieldParentPtr(MakeHexStep, "step", step);
        const cwd = fs.cwd();
        const image = try cwd.openFile(self.input_name, fs.File.OpenFlags{});
        defer image.close();
        const hex = try cwd.createFile(self.output_name, fs.File.CreateFlags{});
        defer hex.close();
        var offset: usize = 0;
        var read_buf: [model.flash.size]u8 = undefined;
        while (true) {
            var n = try image.read(&read_buf);
            if (n == 0) {
                break;
            }
            while (offset < n) {
                if (offset % 0x10000 == 0) {
                    try writeHexRecord(hex, 0, 0x04, &[_]u8{ @truncate(u8, offset >> 24), @truncate(u8, offset >> 16) });
                }
                const i = std.math.min(hex_record_len, n - offset);
                try writeHexRecord(hex, offset % 0x10000, 0x00, read_buf[offset .. offset + i]);
                offset += i;
            }
        }
        try writeHexRecord(hex, 0, 0x01, &[_]u8{});
    }
    fn writeHexRecord(file: fs.File, offset: usize, code: u8, bytes: []u8) !void {
        var record_buf: [1 + 2 + 1 + hex_record_len + 1]u8 = undefined;
        var record: []u8 = record_buf[0 .. 1 + 2 + 1 + bytes.len + 1];
        record[0] = @truncate(u8, bytes.len);
        record[1] = @truncate(u8, offset >> 8);
        record[2] = @truncate(u8, offset >> 0);
        record[3] = code;
        for (bytes) |b, i| {
            record[4 + i] = b;
        }
        var checksum: u8 = 0;
        for (record[0 .. record.len - 1]) |b| {
            checksum = checksum -% b;
        }
        record[record.len - 1] = checksum;
        var line_buf: [1 + record_buf.len * 2 + 1]u8 = undefined;
        _ = try file.write(try std.fmt.bufPrint(&line_buf, ":{X}\n", .{record}));
    }
    const hex_record_len = 32;
};

pub fn addCustomStep(self: *std.build.Builder, customStep: var) *@TypeOf(customStep) {
    var allocated = self.allocator.create(@TypeOf(customStep)) catch unreachable;
    allocated.* = customStep;
    allocated.*.step = Step.init(@typeName(@TypeOf(customStep)), self.allocator, @TypeOf(customStep).make);
    return allocated;
}

const fs = std.fs;
const std = @import("std");
const Step = std.build.Step;
