pub fn link() void {
    externs = IndentedStream.open(externs_file_name);
    defer externs.close();
    prepare_memory = IndentedStream.open(prepare_memory_file_name);
    defer prepare_memory.close();
    script = IndentedStream.open(script_file_name);
    defer script.close();
    externs.line("// {} - do not edit - generated by build.zig", .{externs_file_name});
    prepare_memory.line("// {} - do not edit - generated by build.zig", .{prepare_memory_file_name});
    prepare_memory.begin("\npub fn prepareMemory() void", .{});
    script.line("# {} - do not edit - generated by build.zig", .{script_file_name});
    model.linkModel();
    prepare_memory.end("", .{});
    prepare_memory.line("", .{});
    prepare_memory.line("const externs = @import(\"generated_externs.zig\");", .{});
    prepare_memory.line("const std = @import(\"std\");", .{});
}

pub fn linkMemory(comptime memory: type) void {
    current_memory_name = memory.name;
    script.begin("\nMEMORY", .{});
    script.line("{} : ORIGIN = 0x{x}, LENGTH = 0x{x}", .{ memory.name, memory.start, memory.size });
    script.end("", .{});
    memory.linkSections();
}

pub fn discardSections(patterns: []const []const u8) void {
    script.begin("\nSECTIONS", .{});
    script.begin("/DISCARD/ :", .{});
    for (patterns) |p| {
        script.line("*({})", .{p});
    }
    script.end("", .{});
    script.end("", .{});
}

pub fn linkSections(comptime options: SectionOptions, patterns: []const []const u8) void {
    script.begin("\nSECTIONS", .{});
    if (options.prepare_by_copying_from) |mem| {
        script.line("__{}_load_start = {}_clc;", .{ options.name, mem.name });
        script.begin(".some_section_name : AT({}_clc)", .{mem.name});
        script.line("__{}_start = .;", .{options.name});
        externs.line("\npub extern var __{}_start: u8;", .{options.name});
        externs.line("pub extern var __{}_end: u8;", .{options.name});
        externs.line("pub extern var __{}_load_start: u8;", .{options.name});
        prepare_memory.line("", .{});
        prepare_memory.line("var {}_destination = @ptrCast([*]u8, &externs.__{}_start)[0 .. @ptrToInt(&externs.__{}_end) - @ptrToInt(&externs.__{}_start)];", .{ options.name, options.name, options.name, options.name });
        prepare_memory.line("var {}_loaded = @ptrCast([*]u8, &externs.__{}_load_start)[0..{}_destination.len];", .{ options.name, options.name, options.name });
        prepare_memory.line("std.mem.copy(u8, {}_destination, {}_loaded);", .{ options.name, options.name });
    } else if (options.prepare_by_setting_to_zero) {
        script.begin(".some_section_name (NOLOAD) :", .{});
        script.line("__{}_start = .;", .{options.name});
        externs.line("", .{});
        externs.line("pub extern var __{}_start: u8;", .{options.name});
        externs.line("pub extern var __{}_end: u8;", .{options.name});
        prepare_memory.line("", .{});
        prepare_memory.line("var {} = @ptrCast([*]u8, &externs.__{}_start)[0 .. @ptrToInt(&externs.__{}_end) - @ptrToInt(&externs.__{}_start)];", .{ options.name, options.name, options.name, options.name });
        prepare_memory.line("std.mem.set(u8, {}, 0);", .{options.name});
    } else {
        script.begin(".some_section_name :", .{});
    }
    for (patterns) |p| {
        if (options.keep) {
            script.line("KEEP(*({}))", .{p});
        } else {
            script.line("*({})", .{p});
        }
    }
    if (options.prepare_by_setting_to_zero or options.prepare_by_copying_from != null) {
        script.line("__{}_end = .;", .{options.name});
    }
    script.line("{}_clc = .;", .{current_memory_name});
    script.end(" > {}", .{current_memory_name});
    script.end("", .{});
}

const IndentedStream = struct {
    pub fn begin(self: *IndentedStream, comptime format: []const u8, args: var) void {
        self.line(format ++ " {{", args);
        self.indent += 1;
    }
    pub fn close(self: *IndentedStream) void {
        self.file.close();
    }
    pub fn end(self: *IndentedStream, comptime format: []const u8, args: var) void {
        self.indent -= 1;
        self.line("}}" ++ format, args);
    }
    pub fn line(self: *IndentedStream, comptime format: []const u8, args: var) void {
        var i: u32 = 0;
        while (i < self.indent) : (i += 1) {
            self.file.writeAll("    ") catch unreachable;
        }
        self.stream.print(format ++ "\n", args) catch unreachable;
    }
    pub fn open(file_name: []const u8) IndentedStream {
        var self: IndentedStream = undefined;
        self.indent = 0;
        self.file = fs.cwd().createFile(file_name, fs.File.CreateFlags{}) catch unreachable;
        self.stream = self.file.outStream();
        return self;
    }
    file: fs.File,
    indent: u32,
    stream: std.io.OutStream(fs.File, std.os.WriteError, fs.File.write),
};

const externs_file_name = generated_path ++ "generated_externs.zig";
const fs = std.fs;
const model = @import("system_model.zig");
const prepare_memory_file_name = generated_path ++ "generated_prepare_memory.zig";
const SectionOptions = struct {
    keep: bool = false,
    name: ?[]const u8 = null,
    prepare_by_copying_from: ?type = null,
    prepare_by_setting_to_zero: bool = false,
};
const std = @import("std");
pub const generated_path = "generated/generated_linker_files/";
pub const script_file_name = generated_path ++ "generated_linker_script.ld";
var current_memory_name: []const u8 = undefined;
var externs: IndentedStream = undefined;
var prepare_memory: IndentedStream = undefined;
var script: IndentedStream = undefined;
