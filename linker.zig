fn discardSections(patterns: []const []const u8) void {
    script.begin("\nSECTIONS", .{});
    script.begin("/DISCARD/ :", .{});
    for (patterns) |p| {
        script.line("*({})", .{p});
    }
    script.end("", .{});
    script.end("", .{});
}

fn link(comptime model: type) void {
    externs = IndentedStream.open(externs_file_name);
    defer externs.close();
    prepare_memory = IndentedStream.open(prepare_memory_file_name);
    defer prepare_memory.close();
    script = IndentedStream.open(script_file_name);
    defer script.close();
    externs.line("// {} - do not edit - generated by build.zig", .{externs_file_name});
    prepare_memory.line("// {} - do not edit - generated by build.zig", .{prepare_memory_file_name});
    prepare_memory.begin("\npub fn prepareMemory() void", .{});
    script.line("# {} - do not edit - generated by build.zig", .{script_file_name});
    model.linkModel();
    script.line("\n# .ARM.exidx must be discarded until \"provide -fno-unwind-tables\" is resolved https://github.com/ziglang/zig/issues/5464", .{});
    discardSections(&[_][]const u8{".ARM.exidx"});
    prepare_memory.end("", .{});
    prepare_memory.line("", .{});
    prepare_memory.line("const externs = @import(\"generated_externs.zig\");", .{});
    prepare_memory.line("const std = @import(\"std\");", .{});
}

fn stepType(comptime model: type) type {
    const SomeStep = struct {
        comptime model: type = model,
        step: std.build.Step = undefined,
        pub fn make(step: *std.build.Step) anyerror!void {
            link(model);
        }
    };
    return SomeStep;
}

pub fn linkMemory(comptime memory: type) void {
    current_memory_name = memory.name;
    script.begin("\nMEMORY", .{});
    script.line("{} : ORIGIN = 0x{x}, LENGTH = 0x{x}", .{ memory.name, memory.start, memory.size });
    script.end("", .{});
    script.begin("\nSECTIONS", .{});
    memory.linkSections();
    script.end("", .{});
}

pub fn linkSections(comptime options: SectionOptions, patterns: []const []const u8) void {
    if (options.prepare_by_copying_from) |mem| {
        script.begin(".determine_load_start_for_{} :", .{options.name});
        script.line("__{}_load_start = .;", .{options.name});
        script.end(" > {}", .{mem.name});
        script.begin(".{} : AT(__{}_load_start)", .{ options.name, options.name });
        script.line("__{}_start = .;", .{options.name});
        externs.line("\npub extern var __{}_start: u8;", .{options.name});
        externs.line("pub extern var __{}_end: u8;", .{options.name});
        externs.line("pub extern var __{}_load_start: u8;", .{options.name});
        prepare_memory.line("", .{});
        prepare_memory.line("var {}_slice = @ptrCast([*]u8, &externs.__{}_start)[0 .. @ptrToInt(&externs.__{}_end) - @ptrToInt(&externs.__{}_start)];", .{ mem.name, options.name, options.name, options.name });
        prepare_memory.line("var {}_slice = @ptrCast([*]u8, &externs.__{}_load_start)[0..{}_slice.len];", .{ current_memory_name, options.name, mem.name });
        prepare_memory.line("std.mem.copy(u8, {}_slice, {}_slice);", .{ current_memory_name, mem.name });
    } else if (options.prepare_by_setting_to_zero) {
        script.begin(".{} (NOLOAD) :", .{options.name});
        script.line("__{}_start = .;", .{options.name});
        externs.line("", .{});
        externs.line("pub extern var __{}_start: u8;", .{options.name});
        externs.line("pub extern var __{}_end: u8;", .{options.name});
        prepare_memory.line("", .{});
        prepare_memory.line("var {} = @ptrCast([*]u8, &externs.__{}_start)[0 .. @ptrToInt(&externs.__{}_end) - @ptrToInt(&externs.__{}_start)];", .{ current_memory_name, options.name, options.name, options.name });
        prepare_memory.line("std.mem.set(u8, {}, 0);", .{current_memory_name});
    } else {
        script.begin(".{} :", .{options.name});
    }
    for (patterns) |p| {
        if (options.keep) {
            script.line("KEEP(*({}))", .{p});
        } else {
            script.line("*({})", .{p});
        }
    }
    if (options.prepare_by_setting_to_zero or options.prepare_by_copying_from != null) {
        script.line("__{}_end = .;", .{options.name});
    }
    script.end(" > {}", .{current_memory_name});
}

pub fn addGenerateLinkerFilesStep(b: *std.build.Builder, comptime model: type) *stepType(model) {
    var allocated = b.allocator.create(stepType(model)) catch unreachable;
    allocated.*.step = std.build.Step.init(.Custom, @typeName(stepType(model)), b.allocator, stepType(model).make);
    return allocated;
}

const IndentedStream = struct {
    pub fn begin(self: *IndentedStream, comptime format: []const u8, args: var) void {
        self.line(format ++ " {{", args);
        self.indent += 1;
    }
    pub fn close(self: *IndentedStream) void {
        self.file.close();
    }
    pub fn end(self: *IndentedStream, comptime format: []const u8, args: var) void {
        self.indent -= 1;
        self.line("}}" ++ format, args);
    }
    pub fn line(self: *IndentedStream, comptime format: []const u8, args: var) void {
        var i: u32 = 0;
        while (i < self.indent) : (i += 1) {
            self.file.writeAll("    ") catch unreachable;
        }
        self.stream.print(format ++ "\n", args) catch unreachable;
    }
    pub fn open(file_name: []const u8) IndentedStream {
        var self: IndentedStream = undefined;
        self.indent = 0;
        self.file = fs.cwd().createFile(file_name, fs.File.CreateFlags{}) catch unreachable;
        self.stream = self.file.outStream();
        return self;
    }
    file: fs.File,
    indent: u32,
    stream: std.io.OutStream(fs.File, std.os.WriteError, fs.File.write),
};

const externs_file_name = generated_path ++ "generated_externs.zig";
const fs = std.fs;
const prepare_memory_file_name = generated_path ++ "generated_prepare_memory.zig";
const SectionOptions = struct {
    keep: bool = false,
    name: ?[]const u8 = null,
    prepare_by_copying_from: ?type = null,
    prepare_by_setting_to_zero: bool = false,
};
const std = @import("std");
pub const generated_path = "generated/generated_linker_files/";
pub const script_file_name = generated_path ++ "generated_linker_script.ld";
var current_memory_name: []const u8 = undefined;
var externs: IndentedStream = undefined;
var prepare_memory: IndentedStream = undefined;
var script: IndentedStream = undefined;
